0,1,2
"('page_content', 'Divide and Conquer \nAlgorithms \nCPSC 320 2023W2')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 0})","('type', 'Document')"
"('page_content', 'Definitions \nA divide and conquer algorithm proceeds by… \n●Dividing the input into two or more smaller instances of the \nsame problems \n○We call these subproblems \n●Solving the subproblems recursively \n●Combining the subproblem solutions to obtain a solution to \nthe original problem')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 1})","('type', 'Document')"
"('page_content', 'Examples \nSome divide and conquer algorithms you are already familiar \nwith:\n●QuickSort \n●MergeSort')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 2})","('type', 'Document')"
"('page_content', 'Recurrence relations \n●The running time T(n) of a recursive function can be described using \na recurrence relation: \n○T(n) is defined in terms of one or more terms of the form T(something smaller \nthan n) \n○Example:')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 3})","('type', 'Document')"
"('page_content', 'Recursion Trees \n●One way to solve a recurrence relation is to draw a recursion tree \n○Represent the recursion with a tree where each node represents a recursive \nsubproblem \n○Inside each node, write the size of the subproblem this call to the function \nsolves \n○Next to each node, write the amount of work done by the call to the function, \nnot including any time spent in recursive calls \n○Compute the total amount of non-recursive work done on each row \n○Then add up the work done over all rows')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 4})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 5})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 6})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 7})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 8})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 9})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 10})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 11})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 12})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 13})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 14})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 15})","('type', 'Document')"
"('page_content', 'Recursion trees')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 16})","('type', 'Document')"
"('page_content', 'The Master Theorem \n●Most divide and conquer algorithms split the input into \nequal-size subproblems \n●Most recursion trees fall into one of three categories: \n○The work per level increases geometrically \n○The work per level is constant (e.g., MergeSort) \n○The work per level decreases geometrically (e.g., the previous \nexample)')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 17})","('type', 'Document')"
"('page_content', 'The Master Theorem [Bentley, Haken, Saxe]')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 18})","('type', 'Document')"
"('page_content', 'The Master Theorem [Bentley, Haken, and Saxe] \nHow to apply the theorem: \n●Compute logba\n●Compare it to the exponent of n in f(n)\n○If logba is larger: case 1. \n○If they are equal: maybe case 2. \n○If logba is smaller: check regularity condition, and if it holds then case \n3.')","('metadata', {'source': 'Preprocessing/Data/Origin/testpdf_2.pdf', 'page': 19})","('type', 'Document')"
