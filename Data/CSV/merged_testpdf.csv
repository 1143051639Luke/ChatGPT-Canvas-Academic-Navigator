0,1,2
"('page_content', 'Greedy Algorithms \nCPSC 320 2023W2')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_1.pdf', 'page': 0})","('type', 'Document')"
"('page_content', 'Optimization problems \n●The next few worksheets will cover optimization problems :\n○We have a problem with several valid solutions \n○There is an objective function that tells us how good (or bad) each solution \nis\n○We are looking for the valid solution that minimizes or maximizes the value of \nthe objective function \n●We will look at two algorithm design paradigms: \n○Greedy algorithms \n○Dynamic programming')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_1.pdf', 'page': 1})","('type', 'Document')"
"('page_content', 'Optimization problems \nExamples: \n●Given a set of intervals, find the largest set of intervals that don’t overlap. \n○The objective function is the cardinality of the set \n●Given a set of jobs with deadlines, order the jobs so as to minimize their \ntotal lateness \n○Objective function is the total lateness \n●Given a weighted connected graph, find a spanning tree with the smallest \ntotal edge weight \n○Objective function is the sum of the weights of the edges in the spanning tree')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_1.pdf', 'page': 2})","('type', 'Document')"
"('page_content', 'Defining greedy algorithms \n●A greedy algorithm  proceeds by: \n○Making a choice based on a simple, local criterion \n○Solving the subproblem that results from that choice \n○Combining the choice and the subproblem choice \n●We can think of a greedy algorithm as making a sequence of \n(locally “good”) choices. \n●There is no precise definition of “greedy.”')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_1.pdf', 'page': 3})","('type', 'Document')"
"('page_content', 'Defining greedy algorithms \nExamples of choice: \n●Choosing the interval with the earliest finish time. \n●Choosing the job with the earliest deadline. \n●Choosing the item needed further in the future. \n●Choosing the smallest weight edge that does not create a cycle.')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_1.pdf', 'page': 4})","('type', 'Document')"
"('page_content', 'Defining greedy algorithms \nDoes a greedy algorithm always give the correct solution? \n●Sometimes yes, sometimes no. \n●There are some classes of problems (e.g., matroids) for which \nthere exists a greedy algorithm that always returns the correct \nsolution. \n●There are other problems where no one knows any greedy \nalgorithm with this property (e.g., weighted interval scheduling). \n●There are some problems where greedy doesn’t give an optimal \nsolution, but it’s provably *close* to optimal in some sense (e.g., \ntraveling salesperson).')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_1.pdf', 'page': 5})","('type', 'Document')"
"('page_content', 'Proving a greedy algorithm correct \nMethod 1: “the greedy algorithm stays ahead” \n●Essentially a proof by induction \n●You compare the list of choices made by the greedy algorithm, to a \nsimilar list of choices made by an optimal solution \n●Show that at each stage, the greedy choice is at least as good as the \nchoice in the optimal solution \n●Example: algorithm for interval scheduling problem (4.1)')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_1.pdf', 'page': 6})","('type', 'Document')"
"('page_content', 'Proving a greedy algorithm correct \nMethod 2: exchange arguments \n●Prove that if O is an optimal solution, and G is the greedy solution, then \nyou can modify O slightly to get O’ such that: \n○O’ is more similar to G than O was\n○O’ is at least as good a solution as O\n●Then describe how you can repeatedly modify O until it is the same \nsolution as G, without ever decreasing the solution quality \n●Examples of what “more similar to” might mean: \n○Has more edges in common with \n○Selects more of the same jobs \n○Has fewer elements out of order compared with the greedy solution')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_1.pdf', 'page': 7})","('type', 'Document')"
"('page_content', 'Divide and Conquer \nAlgorithms \nCPSC 320 2023W2')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 0})","('type', 'Document')"
"('page_content', 'Definitions \nA divide and conquer algorithm proceeds by… \n●Dividing the input into two or more smaller instances of the \nsame problems \n○We call these subproblems \n●Solving the subproblems recursively \n●Combining the subproblem solutions to obtain a solution to \nthe original problem')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 1})","('type', 'Document')"
"('page_content', 'Examples \nSome divide and conquer algorithms you are already familiar \nwith:\n●QuickSort \n●MergeSort')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 2})","('type', 'Document')"
"('page_content', 'Recurrence relations \n●The running time T(n) of a recursive function can be described using \na recurrence relation: \n○T(n) is defined in terms of one or more terms of the form T(something smaller \nthan n) \n○Example: \nOne\nrecursivecallonn/2items.\nTworecursivecallsonn/4items.\nworknotdone\neinsidearecursive\ncall\nn/2)+2T(n/ 4)\n+n\nifn≥4\nT(n)=\nifn≤3')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 3})","('type', 'Document')"
"('page_content', 'Recursion Trees \n●One way to solve a recurrence relation is to draw a recursion tree \n○Represent the recursion with a tree where each node represents a recursive \nsubproblem \n○Inside each node, write the size of the subproblem this call to the function \nsolves \n○Next to each node, write the amount of work done by the call to the function, \nnot including any time spent in recursive calls \n○Compute the total amount of non-recursive work done on each row \n○Then add up the work done over all rows')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 4})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the tree')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 5})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the treeT(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nif n≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 6})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the treeT(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nif n≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 7})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the treeT(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nif n≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 8})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the treeT(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nif n≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)\nn/8\n(n/16)\n(n/16)')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 9})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the treeT(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nif n≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2 T(n/4)+n²\nifn≥4\nT(n)=\n(1)\nifn≤3\nExample: work done at each node\nn2\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16)')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 10})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the treeT(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nif n≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2 T(n/4)+n²\nifn≥4\nT(n)=\n(1)\nifn≤3\nExample: work done at each node\nn2\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: work done at each node (continued)\nn2\nn/2\n(n/2)2\nn/4\nn/4\nn/4\nn/8\nn/8)\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 11})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the treeT(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nif n≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2 T(n/4)+n²\nifn≥4\nT(n)=\n(1)\nifn≤3\nExample: work done at each node\nn2\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: work done at each node (continued)\nn2\nn/2\n(n/2)2\nn/4\nn/4\nn/4\nn/8\nn/8)\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16T(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: work done at each node (continued)\nn2\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16）\nn/8\n(n/16)\nn/16\n(n/4)² (n/8)2\n(n/8)2 (n/8)2 (n/16)2(n/16)2(n/8)2(n/16)2 (n/16)2')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 12})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the treeT(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nif n≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2 T(n/4)+n²\nifn≥4\nT(n)=\n(1)\nifn≤3\nExample: work done at each node\nn2\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: work done at each node (continued)\nn2\nn/2\n(n/2)2\nn/4\nn/4\nn/4\nn/8\nn/8)\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16T(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: work done at each node (continued)\nn2\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16）\nn/8\n(n/16)\nn/16\n(n/4)² (n/8)2\n(n/8)2 (n/8)2 (n/16)2(n/16)2(n/8)2(n/16)2 (n/16)2T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n(1)\nifn≤3\nExample: work done on each row\nn2\nn2\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\nn/16\n(n/16）\n(n/4)² (n/8)2\n(n/8)2 (n/8) (n/16)2(n/16)(n/8)2(n/16)2 (n/16)2')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 13})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the treeT(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nif n≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2 T(n/4)+n²\nifn≥4\nT(n)=\n(1)\nifn≤3\nExample: work done at each node\nn2\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: work done at each node (continued)\nn2\nn/2\n(n/2)2\nn/4\nn/4\nn/4\nn/8\nn/8)\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16T(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: work done at each node (continued)\nn2\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16）\nn/8\n(n/16)\nn/16\n(n/4)² (n/8)2\n(n/8)2 (n/8)2 (n/16)2(n/16)2(n/8)2(n/16)2 (n/16)2T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n(1)\nifn≤3\nExample: work done on each row\nn2\nn2\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\nn/16\n(n/16）\n(n/4)² (n/8)2\n(n/8)2 (n/8) (n/16)2(n/16)(n/8)2(n/16)2 (n/16)2T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: work done on each row\nn2\nn²/4+n2/16+n2/16\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\n= (3/8)n2\nn/4\nn/8\nn/8)\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16\n(n/4)² (n/8)2\n(n/8)2 (n/8)2 (n/16)2(n/16)(n/8)2(n/16)2 (n/16)2')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 14})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the treeT(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nif n≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2 T(n/4)+n²\nifn≥4\nT(n)=\n(1)\nifn≤3\nExample: work done at each node\nn2\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: work done at each node (continued)\nn2\nn/2\n(n/2)2\nn/4\nn/4\nn/4\nn/8\nn/8)\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16T(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: work done at each node (continued)\nn2\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16）\nn/8\n(n/16)\nn/16\n(n/4)² (n/8)2\n(n/8)2 (n/8)2 (n/16)2(n/16)2(n/8)2(n/16)2 (n/16)2T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n(1)\nifn≤3\nExample: work done on each row\nn2\nn2\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\nn/16\n(n/16）\n(n/4)² (n/8)2\n(n/8)2 (n/8) (n/16)2(n/16)(n/8)2(n/16)2 (n/16)2T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: work done on each row\nn2\nn²/4+n2/16+n2/16\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\n= (3/8)n2\nn/4\nn/8\nn/8)\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16\n(n/4)² (n/8)2\n(n/8)2 (n/8)2 (n/16)2(n/16)(n/8)2(n/16)2 (n/16)2T(n/2)+2 T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample:workdoneoneachrow\nn2\nn²/4+n²/16+n²/16\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\n= (3/8)n2\nn²/16+...+n2/256\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16\n= (3/8)2n2\n(n/4)2 (n/8)2\n(n/8)2 (n/8)² (n/16)2(n/16)²(n/8)2(n/16)² (n/16)2')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 15})","('type', 'Document')"
"('page_content', 'Recursion trees \nT(n/2)+2T(n/4)+n^\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the treeT(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nif n≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n[0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: drawing the tree (continued)\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\nn/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2 T(n/4)+n²\nifn≥4\nT(n)=\n(1)\nifn≤3\nExample: work done at each node\nn2\nn/2\nn/4\nn/4\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16)T(n/2)+2T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: work done at each node (continued)\nn2\nn/2\n(n/2)2\nn/4\nn/4\nn/4\nn/8\nn/8)\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16T(n/2)+2 T(n/4)+n²\nif n≥ 4\nT(n)=\n0(1)\nifn≤3\nExample: work done at each node (continued)\nn2\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16）\nn/8\n(n/16)\nn/16\n(n/4)² (n/8)2\n(n/8)2 (n/8)2 (n/16)2(n/16)2(n/8)2(n/16)2 (n/16)2T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n(1)\nifn≤3\nExample: work done on each row\nn2\nn2\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\nn/16\n(n/16）\n(n/4)² (n/8)2\n(n/8)2 (n/8) (n/16)2(n/16)(n/8)2(n/16)2 (n/16)2T(n/2)+2T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: work done on each row\nn2\nn²/4+n2/16+n2/16\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\n= (3/8)n2\nn/4\nn/8\nn/8)\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16\n(n/4)² (n/8)2\n(n/8)2 (n/8)2 (n/16)2(n/16)(n/8)2(n/16)2 (n/16)2T(n/2)+2 T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample:workdoneoneachrow\nn2\nn²/4+n²/16+n²/16\nn/2\n(n/2)2\nn/4\n(n/4)2\nn/4\n(n/4)2\n= (3/8)n2\nn²/16+...+n2/256\nn/4\nn/8\nn/8\nn/8\n(n/16\n(n/16)\nn/8\n(n/16)\n(n/16\n= (3/8)2n2\n(n/4)2 (n/8)2\n(n/8)2 (n/8)² (n/16)2(n/16)²(n/8)2(n/16)² (n/16)2T(n/2)+2 T(n/4)+n²\nifn≥4\nT(n)=\n0(1)\nifn≤3\nExample: summing up the work on all the rows\nThe total work is n2 + (3/8)n2 + (3/8)²n2 +\nThis is a geometric series, and 3/8 < 1.\nSo the sum converges to\n1-3/8\nHence\nT(n)∈θ(n²)')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 16})","('type', 'Document')"
"('page_content', 'The Master Theorem \n●Most divide and conquer algorithms split the input into \nequal-size subproblems \n●Most recursion trees fall into one of three categories: \n○The work per level increases geometrically \n○The work per level is constant (e.g., MergeSort) \n○The work per level decreases geometrically (e.g., the previous \nexample)')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 17})","('type', 'Document')"
"('page_content', ""The Master Theorem [Bentley, Haken, Saxe] \nTheorem: Let a ≥ 1, b > 1 be real constants, letf: N → R+, and\nlet T(n) be defined by:\naT(n/b)+f (n)\nifn≥no\nT(n)=\n0(1)\nifn<no\nwhere n/b might be either [n/b] or [n/b] . Then\n1. If f (n)∈O(n\nlogba-e\nfor some e>0 then T(n)∈O(n'\nlogba\n2. If f (n)∈θ(nlogα l1og* n) for some k≥0 then T(n)∈⊙(nl\nnlogalog\nk+1\n3. If f (n)∈(nloga+e)\nfor some e>0\nand af (n/b)<of (n)\nfor\nsome\n 0<o<1 and all n large enough, then T (n)∈θ(f (n)).\nregularity condition"")","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 18})","('type', 'Document')"
"('page_content', 'The Master Theorem [Bentley, Haken, and Saxe] \nHow to apply the theorem: \n●Compute logba\n●Compare it to the exponent of n in f(n)\n○If logba is larger: case 1. \n○If they are equal: maybe case 2. \n○If logba is smaller: check regularity condition, and if it holds then case \n3.')","('metadata', {'source': 'Preprocessing/Data/Orginal/testpdf_2.pdf', 'page': 19})","('type', 'Document')"
